---
title: Video 3.9-11 Hacks
layout: default
description: Hacks and Notes for 3.9-11
tags: [week4, notes]
---

## Notes
### 3.9 Video 1
#### Essential Knowledge
- Algorithms can be written in different ways and still accomplish the same tasks
- Algorithms that appear similar can yield different side effects or results
- Some conditional statements can be written as equivalent Boolean expressions
- Some Boolean expressions can be written as equivalent conditional statements
- Different algorithms can be developed or used to solve the same problem
#### Conditional vs Boolean
- How could this conditional scenario be replaced with a boolean scenario?   

- IF (isHoliday)   
- {   
    - school⟵false   
- }   
- ELSE   
- {   
    - IF(isWeekday)   
    - {   
        - school⟵true   
    - }   
    - ELSE   
    - {   
        - school⟵false   
    - }   
- }   

**What needs to be true and what needs to be false in order for you to go to school?**
- First conditional: If isHoliday is true, you do not need to go to school
- Second conditional: If isWeekday is true, you do need to go to school. However, if it is false, school also becomes false

**Therefore, in pseudo code, this statement could be written as:**
- school⟵((NOT (isHoliday)) AND (isWeekday))
- Keep in mind that both of these statements yield the same results, and neither of them are incorrect

#### More Comparing Algorithms
The algorithms below are to sum the odd numbers from 1 to 9 (1+3+5+7+9). Do they each work as intended?

1. 
- sum⟵1
- counter⟵3
- REPEAT 4 TIMES
    - sum⟵sum + counter
    - counter⟵counter + 2
- DISPLAY sum

2. 
- sum⟵0
- counter⟵9
- REPEAT UNTIL counter < 1
    - sum⟵sum + counter
    - counter⟵counter - 2
- DISPLAY sum

**Why is it important to understand that algorithms can be written in different ways and still accomplish the same tasks?**

### 3.9 Video 2
#### Essential Knowledge 
- Algorithms can be created from an idea, 
  by combining existing algorithms, 
  or by modifying existing algorithms.

#### Vocab
- Iteration: Repeating steps, or instructions over and over again. 
( this could be also often called a loop ) 
- Selection: is a decision or question. At some point in an algorithm there may need to be a question because the algorithm has reached a step where one or more options are available.
### 3.9 Video 3

#### Essential Knowledge 
- Knowledge of existing algorithms can help in constructing new ones. Some existing algorithms include:
Determining the maximum or minimum value of two or more numbers.
Computing the sum or average of two or more numbers.
Identifying if an integer is or is not evenly divisible by another integer.
Determining a robot's path through a maze.
- Using existing correct algorithms as building blocks for constructing another algorithm has benefits such as reducing development time, reduce testing, and simplifying the identification of errors.

#### Vocab 
- Algorithm: A process or set of rules to be followed in calculations or other problem solving operations, especially by a computer.
### 3.11
#### Learning Objective
- For binary search algorithims
    - Determine the number of iterations required to find a value in a data set. 
    - Explain the requirements necessary to complete a binary search.
- The binary search algorithm starts at the middle of a sorted data set of numbers and eliminates half of the data; this process repeats until the desired value is found or all elements have been eliminated.
- Data must be in sorted order to use the binary search algorithm 
- A binary search is often more efficient than sequential/linear search when applied to sorted data.

#### Essential knowledge
- Imagine you had to search for a number in a huge set. How would you do it? Would you pick randomly or would you put them in order first?

## Hacks
### Question 1
Write this Boolean statement in the form of a conditional (if/else) statement: stayInside⟵((isCold) OR (isRaining))

{
if(isRaining){
    day --> "cold"
}
if(isCold){
    day --> "cold"
}
}

### Question 2
Create an algorithm that uses selection and/or iteration that will represent one player's complete turn.

import random

def turn():
    max = 0
    for i in range(4):
        start = random.randint(1, 10)
        if start > max:
            max = max
    print(max)

turn()
turn()

### Question 3
Create an algorithm that will allow the arrow to reach the gray square:

{
if CANMOVEFORWARD{
    moveForwards
}
else{
    if CANTURNRIGHT{
        turnright
    }
    if CANTURNLEFT{
        turnleft
    }
}
}

### Question 4
Make a binary search tree of different the list [1,2,3,4,6,9,11,69]

![image.png](attachment:image.png)

### Question 5

You would start your search for element 69 by looking at the middle index, 5, first (4.5, round up to 5). That is six. Six being less than 69 would lead you to consider the more than half. The middle index for this section is 7 (5+9 = 14/2 = 7). Index number seven is 11, which is lower than index number 69. The eighth index is next examined ((8+8)/2 = 8). We searched and discovered the right number since 8 = 69.

### Question 6

(8+1)/2 = 4.5 -> lst[5] = 6

(5+8)/2 = 12.5 -> lst[13] = 11

(8+8)/2 = 8 -> lst[8] =69

### Question 7

["Market”, ”Ralphs”, “store”, "Target”, ”Walmart”]

To place them in alphabetical order, ascending, you may add these in this sequence. As numbers are bigger, you may compare which numerical value of these ascii characters is greater, allowing these to be appropriately compared.

### Question 8

Due to the fact that binary search automatically filters out half of the options with each iteration, it is much faster than sequential search. Since you begin at the center index, you can either select the group that is higher or lower than the middle index. As a result, each time you make a cut, you will eliminate half of the potential outcomes.

### Question 9

I would look for number 36 out of the list [64,36,16,11,9]. First, I would choose the middle element ((1+5)/2 = 3, which is the middle element for collegeboard purposes), and since 16 is less than 36, I would shift back (as the list is reversed). As a result, I would choose the second element (1+3/2 = 2), which equals 36, therefore it would take me two tries to reach 36.